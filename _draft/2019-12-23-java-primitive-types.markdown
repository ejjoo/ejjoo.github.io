---
layout: post
title: 자바의 놓치기 쉬운 내용들
date: 2019-12-31 21:25:54 +0900
categories: java
---

## 부동소숫점
- Java의 부동소숫점은 0으로 나누는것이 가능하다.
  - 1.0 / 0.0 = Infinity
  - 0.0 / 0.0 = NaN (not a number)
    - NaN == NaN은 true가 아니다. NaN 검사를 위해서는 Float.isNaN를 사용해야한다.
  - 2.0 - 1.1은 0.8999999
    - 2진수에서 나누어떨어지지 않기때문에 반올림 오류가 발생
      - BigDecimal의 Exact...  메소드를 이용해 처리 가능하다.
  - 메소드에 strictfp 제어문을 추가하면 deterministic한 연산결과를 얻을수 있다.
- Math의 (add,subtract,increment,decrement,negate)Exact메소드들은 오버플로우가 발생하면 예외를 발생한다.
- BigInteger를 사용하면 이론적으로 무한대에 가까운 정수를 저장, 계산할수 있다.
- StringBuilder, StringBuffer의 차이점은 Buffer는 모든 구문에 synchronized가 붙어있다.
- String <-> Int
  - Integer.toString(), Integer.parseInt(), String.valueOf()
- CharSequence는 String, StringBuilder, StringBuffer등 문자열을 나타내는 클래스들의 슈퍼타입(인터페이스)
- 자바는 유니코드가 16비트에서 21비트로 옮겨가던 과도기에 만들어졌기 때문에 유니코드 코드포인트를 원래의 시퀀스가 아니라 UTF-16으로 인코딩한 시퀀스를 사용한다.
  - 일부 중국어와 특수문자가 필요없다면 charAt으로 바로 코드포인트를 받아와도 된다.
  - 제대로 처리하려면 codePointAt을 사용해야한다. 코드포인트의 총수는 codePointCount로 확인할 수 있따.
  - Java8부터 CharSequence에 codePoints()로 코드포인트의 스트림을 받아올수 있는 메소드가 추가되었다.
  - 차기버전에서는 UTF-8을 사용하도록 바뀔수도 있다.
  - UTF-8과 16의 차이 (https://pickykang.tistory.com/13)

## 표준입출력
  - 표준입력을 위해서는 System.in을 사용하지만 한글자 단위만 처리가능하므로 Scanner를 사용. Scanner scanner = new Scanner(System.in)
    - next(공백), nextLine(라인), nextInt(정수)등의 메소드로 리터럴을 구분가능하다.
    - 비밀번호용으로 console을 사용할수도 있다. 
      - Console terminal = System.console();
      - terminal.readPassword("Password: ");
    - 파일 입출력을 하고싶을때는 shell의 redirection사용
      - java test.class < input > output.log
  - System.out.printf
    - System.out(String.format()) 같은 미련한 짓을 했구나..
    - $로 인수 인덱스를 지정할수 있다. <는 바로 이전에 사용한 인자 인덱스

## 오브젝트의 크기
  - Object의 구조
    - ObjectHeader
      - Klass Pointer
        - 클래스 포인터, 8byte를 사용해야할것 같지만 CompressedOops옵션이 기본으로 활성화 되어있기 때문에 4byte만 사용함
      - Mark Word
        - 4byte 였으나, 64bit arch 이후 8byte 사용
        - Usage
          - Biased Locking
            - 한 쓰레드에서만 사용하는 오브젝트일 경우 synchronization로직에서 좀 더 퍼포먼스 이득을얻을 수 있음. JVM 옵션에서 활성화 필요함
          - GC Flag
    - String
      - oops 활성화의 경우
      - ObjectHeader = 16
      - pointerToArray = 4
      - 2 Hashes (Integer) = 8
      - No Padding Needed
      - 32byte.
    - Array
      - ObjectHeader + Size = 16 (4byte oops 기준)

## 객체
- 생성자에서는 첫줄에서 this, super로 다른 생성자를 참조할 수 있다.
public class Foo {
    public Foo() {
    }
}

- 로컬변수와는 달리 멤버변수는 타입에 따라 0, null, ""로 초기화 된다.
- 클래스를 참조할때 호출되는 초기화 블록을 사용하는것도 가능하다.
  - 정적클래스에서는 static {} 으로 사용


          - 객체
          - 생성자에서는 첫줄에서 this, super로 다른 생성자를 참조할 수 있다.
          - 멤버변수는 자동으로 0, null, ""로 초기화 된다. 로컬변수는 초기화하지 않을경우 익셉션 발생
          - 초기화에는 클래스를 참조할때 호출되는 초기화 블록을 사용하는것도 가능하다.
            - 정적클래스에서는 static {} 으로 사용
        - 패키지
          - 패키지와 다른 폴더에 빌드된 클래스 파일이 위치하지 않는경우 클래스파일을 찾지 못한다.
            - javac -d 옵션으로 올바른 위치에 클래스파일을 배치할 수 있다.
          - jar파일 생성
            - tar와 동일한 방식
              - -리터럴에도 다중문자 옵션이 사용 가능함
            - classpath를 전달하지 않을 경우 기본으로 '.'이 들어간다. 다만 전달후에는 '.'는 기본으로 참조되지 않는다.
              - java -cp .:./libs 와 같은 형태로 사용
              - 유닉스에서 쉘 확장을 막으려면 \*를 사용해야한다
              - 자주쓰는 폴더는 환경변수에 CLASSPATH에 등록해두면 좋다. (.m2)
          - public, private 제어자를 넣지 않으면 동일 패키지 내에서만 접근을 허용한다.
          - 동일한 클래스의 인스턴스간에는 private 접근이 허용된다.
            - this.privateMathod(a) = Class.privateMethod(this, a)
        - InnerClass
          - 정적내부클래스와 달리 일반 내부 클래스는 상위 클래스의 멤버에 접근이 가능하다.
          - 내부 클래스는 정적 멤버를 가질 수 없다. 
        - 인터페이스
          - java 8 부터는 기본 메서드로 인터페이스 메소드를 정의할 수 있다.
            - 만약 동일한 메서드를 가진 두 인터페이스를 상속한 경우에는 명시적으로 어떤 메서드를 사용할지 정의해야한다
              - public int defaultMethod() { return TargetInterface.super.defaultMethod(); }
              - java 9 부터는 비공개 메서드도 구현이 가능하다.
        - 람다
          - Java 8
          - 타입추론이 가능할경우 ()를 생략할 수 있다.
          - 함수가 하나인 인터페이스 혹은 가상클래스를 참조할 경우 사용가능하다.
          - 값을 추출해 사용할 수 있는 메서드가 생겼음 Comparator.comparing 
          - 
        - 상속
          - super는 객체참조가 아니라 동적 메소드 조회를 우회하는 지시자
          - 함수를 오버라이드 할때 반환타입을 서브타입으로 바꿀수 있다. Access modifier 가 더 strict하지 않을경우 이도 변경 가능하다.
          - 배열을 공변(슈퍼타입에 대입)하는것도 가능하지만 슈퍼타입을 배열에 넣을경우 예외가 발생한다
          - 객체 생성문 뒤에 중괄호로 메서드를 오버라이드하거나 이중중괄호로 함수를 호출할수도 있다 (이중 중괄호는 동등성 검사의 취약점 문제로 비추천)
          - 인터페이스와 슈퍼클래스가 동일한 메서드를 가진다면 슈퍼클래스가 우선된다
          - 자바의 모든 객체는 명시적인 선언 없이도 object를 암시적으로 상속한다
          - instanceof나 “”+string은 null에서도 동작한다
        - Object클래스
          - toString
            - object는 기본적으로  클래스이름+해시코드(java.lang.Object@hashcode)를 리턴한다
            - 다차원 배열은 Array.deepToString으로 출력이 가능하다.
            - 관습적으로 값은 []안에 출력한다.
          - equals
            - 두 클래스가 동등한 객체인지를 검사한다.
            - equals가 true이면 hashCode도 true여야 한다.
              - 역은 성립하지 않을수 있지만, hashMap등에서 해시충돌이 발생하므로 성능에 영향이 있다.
            - 일반적으로 equals에서 instanceof를 사용하는것은 바람직하지 않다. 대칭성이 파괴되기 때문이다. 슈퍼클래스에서 동등성 검사가 고정된 경우는 가능하다.
              - x.equals(y)라면 y.equals(x)여야 한다.
            - 객체의 hashCode를 생성할때 Objects.hash를 사용하면 간단하다
          - hashCode
            - 객체의 메모리 주소와 시퀀스등을 사용해 vm내부에서 자동으로 생성된다.
            - equals를 오버라이드 한다면 이도 오바리읃 해주어야 한다.
          - clone
            - 객체를 얕은복사한다. protected이며, Cloneable로 태깅 (마커라고도 한다)되어있지 않을경우 예외를 발생한다.
            - 배열은 같은 타입의 배열을 리턴하는 clone 함수를 가지고 있다.
            - ArrayList<>.clone는 Object를 리턴하기 때문에 캐스팅이 필요한데, 역사적인 이유로 런타임에 검사를 하지 않기 때문에 warning이 발생한다. @SuppressWarnings("unchecked")로 이를 숨길수 있다.
      - 흐름제어
        - 자바의 switch-case에 사용할수 있는 타입은
          - primitive type, boxing 타입들
          - 스트링 리터럴 (Java 7)
          - enum
      - 래퍼클래스
        - arraylist
          - 이런형태의 초기화도 가능 new ArrayList(List.of(1,2,3))
          - 배열로 ArrayList를 초기화할때도 new ArrayList(List.of(array));
          - Array 복사는 Arrays.copyOf
          - 배열리스트를 배열로 복사할때는
            - array.toArray(new String[10]);
            - 하위호완성때문
          - 래퍼클래스와 원시타입간의 변환은 스트림이나 직접 루프를 돌면서 대입하는수밖에 없다.
          - 배열 초기화하기
            - arr = int[]; Arrays.fill(arr, 0);
            - names = new ArrayList<String>(); Collections.fill(names, "");
          - 정렬
            - 배열은 parallelSort가 사용 가능
          - 배열 문자열로 변환
            - Arrays.toString(arr) or arr.toString()
            - 2차원배열은
              - Arrays.deepToString(matrix2)
          - Collections.reverse, Collections.shuffle 이런것도 있지롱
        - 
        - AutoBoxing
        - 래퍼클래스간의 비교는 객체동일성을 비교하는것에 주의

      - 스트림, 데이터
        - Types
          - File
            - Files.newInputStream(path)
            - Files.newOutputStream(path)
          - URL
            - new URL("").openStream()
          - byte[]
            - new ByteArrayInputStream(bytes)
            - new ByteArrayOutputStream
              - byte[] bytes = out.toByteArray()
        - InputStream
          - in.read() //read 1 byte
          - in.readAllBytes
          - in.readNBytes(bytes, offset, length)
            - read(byte[], int, int)와의 차이점은 read는 실패하면 즉시 적은 개수를 반환한다는 점
          - in.transferTo(out)
        - OutputStream
          - out.write
        - Reader
          - Reader in = InputStreamReader(in, charSet);
          - in.read() //read 1 code unit
        - Channel
          - FileChannel();
          - channel.map();
          - memory mapped file
        - Pattern
          - Pattern pattern = Pattern.compile("regex")
          - Matcher matcher = pattern.matcher("input")
          - matcher.find() //findall
          - matcher.matches() //match exactly
          - matcher.group() //return all patterns
          - matcher.group(1) //substring
          - matcher.start(), matcher.end() //index for substring()
          - (Scanner(in)).findAll("pattern").map(MatchResult:group);
          - gruop은 마지막 일치항목만 리턴
          - 스플릿을 스트림으로 처리
            - string.splitAsStream()
          - replace
            - matcher.replaceAll("test")
      - 표준패키지
        - Javax
          - 표준패키지의 스펙을 지키기 위해, 표준확장패키지들이 모여있는 패키지였다가 표준 라이브러리로 승격 후에도 하위 호완성을 위해 유지되고 있는 패키지들..
        - EE와 SE의 차이점
          - https://210life.tistory.com/entry/Java-EE%EC%99%80-Java-SE%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90
        - J2SE
          - lang, io, net, util
        - J2EE (Enterprise)
          - jdbc, jpa, rmi, jms, servlet, beans
        - Hashmap, Hashtable의 차이점?
        - ConcurrentCollections
        - ExecutorService
      - 멀티쓰레딩
        - Java8
          - Stream
          - Lambda
        - MemoryBarrier, Visibliity
      - JVM
        - JVM구조
        - GC
          - GC란?
          - 메모리 구조
            - Eden(Young), Far(Old?) 이름이 기억안난다.
            - GC옵션들
              - Young, Old를 비율로 나누고 또 여기서 Old1, Old2를 비율로 나눴던것 같은데
              - gcutil로 보통검증?
          - 동작방식
          - GC의 종류
          - GC튜닝
        - 최적화
        - 메모리 구성
          - Before 8
          - Currently
        - Internal
          - Wrapper Class
          - String Intern