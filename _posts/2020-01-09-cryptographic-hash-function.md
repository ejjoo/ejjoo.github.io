---
layout: post
title: 단방향 해시함수와 패스워드 저장
date: 2020-01-09 00:58:36 +0900
categories: general
---
## 주요 속성
* Deterministic, 즉 동일 입력에 대해 동일한 해시를 출력한다.
* 빠른 계산이 가능하다.
* 특정 해시를 생성하는 입력값을 찾는건 불가능하다. (제1역상공격)
* 동일한 해시를 가진 복수개의 입력을 찾는건 불가능하다. (제2역상공격)
* 약간의 입력 변경만으로 완전히 다른 해시를 얻을 수 있다.

## 역상공격
CHF의 공격방식으로 역상공격이라고 하는 해시 충돌 공격이 있다. 이는 특정 해시값을 출력하는 입력값을 찾아내거나, 특정 입력값과 같은 해시를 가지는 다른 입력을 알아내 취약점을 공략하는 방식으로, 비교적 짧은시간안에 이런 형태의 공격이 가능할 경우 해당 함수는 불안정하다고 정의할 수 있다. 이런 이유로 MD5와 같은 함수는 보안적으로 치명적인 곳에 사용하는것은 권하지 않는다.

## 사용 예
* 메시지나 파일의 무결성 확인
  * 전송전후에 Digest를 비교해 변경여부를 체크한다. MD5, SHA1, SHA2 등이 주로 사용된다.
* 서명의 생성과 확인
* 비밀번호 체크
* 작업 증명
* 파일이나 데이터의 식별자

# 해시 함수의 종류
![](/public/images/2-2020-01-09-cryptographic-hash-function.jpg)

## 1. MD5
로널드 리베스트의 주도로 만들어진 해시함수로 과거에도 2,4 버전이 존재했고, 가장 범용적으로 사용되는 MD5는 128비트(16byte) 해시함수로, 1996년에 첫 취약점이 발견된 이후로, 1분내로 해시충돌을 만들어내거나 SSL 인증서를 변조하는 등의 다양한 공격 루트가 존재해 현재는 이용을 권하지 않는다. 2008년 MD6가 발표되었고, NIST의 SHA-3 경쟁에 출품되기도 했다.

![](/public/images/3-2020-01-09-cryptographic-hash-function.png)

* 128비트 고정길이의 출력값을 가진다.
* 고속연산이 가능하기 때문에 대용량 파일의 무결성을 확인하는 용도로 많이 사용한다.
* 입력 메시지를 512 비트 블록으로 쪼개기 때문에 메시지를 패딩하여 512로 나눠떨어지는 길이를 만든다.
  * 첫 단일비트를와 1을 메시지 끝부분에 추가하고, 512배수 길이부터 64비트 적은곳까지 0으로 채운다. 나머지 64비트는 원본 메시지의 길이를 나타내는 64비트 정수를 채운다.


## 2. SHA
NIST와 NSA에서 재정하는 해시 함수집합. 현재는 SHA3까지 발표되었다.

![](/public/images/4-2020-01-09-cryptographic-hash-function.png)

* SHA0과 SHA1은 160비트(20바이트)크기의 다이제스트를 생성한다.
    * 이 두 함수는 취약점이 발견되어 현재는 사용을 권장하지 않는다.
* SHA2는 224,256,384,512등의 크기를 지원하는 변형이 존재한다. 각각의 넘버링으로 부르거나 통칭하여 SHA2로 부른다.
* SHA2가 SHA1와 비슷한 알고리즘을 사용하기 때문에 취약점이 발견될 가능성이 있다고 지적해 SHA3 공모를 진행했다.
    * 2015년 Keccak이 SHA-3로 선정되었다.
    * MD6도 출품되었으나, 속도등의 문제로 인해 선정되지는 않았다.

# 패스워드 저장
일반적으로 패스워드 저장에 단방향 해시함수를 그대로 사용하는것은 권장되지 않는다. 그 이유는 다음과 같다.
- 같은 입력은 항상 동일한 해시값을 가지기 떄문에, 레인보우 테이블등의 공격에 노출될 수 있다.
- 연산속도가 빠르기 때문에 무차별대입(brute-force)에 취약하다.

이를 보완하는 방법은 주로 소금을 뿌린다라는 의미로 입력값 전후로 특정 값(salt)을 삽입하는 Salting이나, 다이제스트값을 다시 입력값으로 사용해 해시를 추출하는 Multiple Slow-Hashing Function 등이 사용된다. 물론 이 둘은 동시에 사용되는 경우가 많다. 이런 두 방식을 사용해 해시값을 생성하는 함수를 키 유도 함수(Key derivation function)라 한다.

![알고리즘별 비용 추산](/public/images/1-2020-01-09-cryptographic-hash-function.png)

### 키 유도 함수
* PBKDF2: 특정 키를 Salting한 HMAC(key+hash)을 지정한 숫자만큼 반복해 해시를 생성하는 방식이며, 가장 많이 사용되기도 한다. 하지만 병렬처리에 취약하다는 단점 또한 가지고 있다.
* bcrypt: 입력값이 72바이트로 고정되는 제약이 있다. 메모리 오버헤드를 통해 PBKDF2보다 비교적 더 안전한 편이나 장비의 가격이 낮아지면서 해킹 난이도 또한 낮아지고 있따. 
* scrypt: PBKDF2와 비슷한 방식이지만 메모리 사용량을 기하급수적으로 높여, 병렬처리를 이용한 공격에 위에 설명한 두 알고리즘보다 더 안전한 편이다. 가장 보안이 강력하다.

##### 참고자료

---
<https://ko.wikipedia.org/wiki/%EC%97%AD%EC%83%81_%EA%B3%B5%EA%B2%A9><br>
<https://en.wikipedia.org/wiki/SHA-2><br>
<https://en.wikipedia.org/wiki/MD5><br>
<https://en.wikipedia.org/wiki/Secure_Hash_Algorithms><br>
<https://medium.com/@mpreziuso/password-hashing-pbkdf2-scrypt-bcrypt-1ef4bb9c19b3><br>
<https://d2.naver.com/helloworld/318732><br>
<http://throwingfire.com/storing-passwords-securely/><br>